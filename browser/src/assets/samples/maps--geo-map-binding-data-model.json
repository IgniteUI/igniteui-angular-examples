{"sampleFiles":[{"hasRelativeAssetsUrls":false,"path":"src/app/maps/geo-map-binding-data-model/map-binding-data-model.component.ts","content":"import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\";\r\nimport { MarkerType } from \"igniteui-angular-charts\";\r\nimport { IgxGeographicMapComponent } from \"igniteui-angular-maps\";\r\nimport { IgxGeographicPolylineSeriesComponent\r\n} from \"igniteui-angular-maps\";\r\nimport { IgxGeographicSymbolSeriesComponent } from \"igniteui-angular-maps\";\r\nimport { WorldUtility } from \"../../utilities/WorldUtility\";\r\n\r\n@Component({\r\n  selector: \"app-map-binding-data-model\",\r\n  styleUrls: [\"./map-binding-data-model.component.scss\"],\r\n  templateUrl: \"./map-binding-data-model.component.html\"\r\n})\r\n\r\nexport class MapBindingDataModelComponent implements AfterViewInit {\r\n\r\n    @ViewChild(\"map\", {static: true})\r\n    public map: IgxGeographicMapComponent;\r\n    @ViewChild(\"pointSeriesTooltipTemplate\", {static: true})\r\n    public pointSeriesTooltipTemplate: TemplateRef<object>;\r\n    @ViewChild(\"polylineSeriesTooltipTemplate\", {static: true})\r\n    public polylineSeriesTooltipTemplate: TemplateRef<object>;\r\n    public flights: any[];\r\n    constructor() {\r\n    }\r\n\r\n    public ngAfterViewInit(): void {\r\n        const cityDAL = { lat:  32.763, lon: -96.663, country: \"US\", name: \"Dallas\" };\r\n        const citySYD = { lat: -33.889, lon: 151.028, country: \"Australia\", name: \"Sydney\" };\r\n        const cityNZL = { lat: -36.848, lon: 174.763, country: \"New Zealand\", name: \"Auckland\" };\r\n        const cityQTR = { lat: 25.285, lon:  51.531,  country: \"Qatar\", name: \"Doha\" };\r\n        const cityPAN = { lat:  8.949, lon: -79.400,  country: \"Panama\", name: \"Panama\" };\r\n        const cityCHL = { lat: -33.475, lon: -70.647, country: \"Chile\", name: \"Santiago\" };\r\n        const cityJAP = { lat:  35.683, lon: 139.809, country: \"Japan\", name: \"Tokyo\" };\r\n        const cityALT = { lat: 33.795,  lon: -84.349, country: \"US\", name: \"Atlanta\" };\r\n        const cityJOH = { lat: -26.178, lon: 28.004,  country: \"South Africa\", name: \"Johannesburg\" };\r\n        const cityNYC = { lat: 40.750, lon: -74.0999, country: \"US\", name: \"New York\" };\r\n        const citySNG = { lat:  1.229, lon: 104.177,  country: \"Singapore\", name: \"Singapore\" };\r\n        const cityMOS = { lat: 55.750, lon:  37.700,  country: \"Russia\", name: \"Moscow\" };\r\n        const cityROM = { lat:  41.880, lon: 12.520,  country: \"Italy\", name: \"Rome\" };\r\n        const cityLAX = { lat: 34.000, lon: -118.25,  country: \"US\", name: \"Los Angeles\" };\r\n\r\n        this.flights = [\r\n            { origin: cityDAL, dest: citySNG, color: \"Green\" },\r\n            { origin: cityMOS, dest: cityNZL, color: \"Red\" },\r\n            { origin: cityCHL, dest: cityJAP, color: \"Blue\" },\r\n            { origin: cityPAN, dest: cityROM, color: \"Orange\" },\r\n            { origin: cityALT, dest: cityJOH, color: \"Black\" },\r\n            { origin: cityNYC, dest: cityQTR, color: \"Purple\" },\r\n            { origin: cityLAX, dest: citySYD, color: \"Gray\" }\r\n        ];\r\n\r\n        for (const flight of this.flights) {\r\n            this.createPolylineSeries(flight);\r\n            this.createSymbolSeries(flight);\r\n        }\r\n    }\r\n\r\n    public createSymbolSeries(flight: any) {\r\n        const geoLocations = [flight.origin, flight.dest ];\r\n        const symbolSeries = new IgxGeographicSymbolSeriesComponent ();\r\n        symbolSeries.dataSource = geoLocations;\r\n        symbolSeries.markerType = MarkerType.Circle;\r\n        symbolSeries.latitudeMemberPath = \"lat\";\r\n        symbolSeries.longitudeMemberPath = \"lon\";\r\n        symbolSeries.markerBrush  = \"White\";\r\n        symbolSeries.markerOutline = flight.color;\r\n        symbolSeries.thickness = 1;\r\n        symbolSeries.tooltipTemplate = this.pointSeriesTooltipTemplate;\r\n\r\n        this.map.series.add(symbolSeries);\r\n    }\r\n\r\n    public createPolylineSeries(flight: any) {\r\n        const geoPath = WorldUtility.calcPaths(flight.origin, flight.dest);\r\n        const geoDistance = WorldUtility.calcDistance(flight.origin, flight.dest);\r\n        const geoRoutes = [\r\n            {\r\n              dest: flight.dest,\r\n              distance: geoDistance,\r\n              origin: flight.origin,\r\n              points: geoPath,\r\n              time: geoDistance / 850\r\n        }];\r\n\r\n        const lineSeries = new IgxGeographicPolylineSeriesComponent ();\r\n        lineSeries.dataSource = geoRoutes;\r\n        lineSeries.shapeMemberPath = \"points\";\r\n        lineSeries.shapeStrokeThickness = 9;\r\n        lineSeries.shapeOpacity = 0.5;\r\n        lineSeries.shapeStroke = flight.color;\r\n        lineSeries.tooltipTemplate = this.polylineSeriesTooltipTemplate;\r\n        this.map.series.add(lineSeries);\r\n    }\r\n}\r\n","isMain":true,"fileExtension":"ts","fileHeader":"ts"},{"hasRelativeAssetsUrls":false,"path":"src/app/maps/geo-map-binding-data-model/map-binding-data-model.component.html","content":"<div class=\"container sample\">\r\n    <igx-geographic-map #map\r\n        width=\"100%\"\r\n        height=\"100%\"\r\n        zoomable=\"true\" >\r\n    </igx-geographic-map>\r\n\r\n    <ng-template let-series=\"series\" let-item=\"item\" #pointSeriesTooltipTemplate>\r\n            <div>\r\n                <span [style.color]=\"series.brush\">{{item.country}}</span>\r\n            </div>\r\n    </ng-template>\r\n\r\n    <ng-template let-series=\"series\" let-item=\"item\" #polylineSeriesTooltipTemplate>\r\n        <div>\r\n            <span [style.color]=\"series.brush\">Departure: {{item.origin.country}}</span><br/>\r\n            <span [style.color]=\"series.brush\">Arrival: {{item.dest.country}}</span>\r\n        </div>\r\n    </ng-template>\r\n\r\n</div>\r\n","isMain":true,"fileExtension":"html","fileHeader":"html"},{"hasRelativeAssetsUrls":false,"path":"src/app/maps/geo-map-binding-data-model/map-binding-data-model.component.scss","content":"/* styles are loaded the Shared CSS file located at:\r\nhttps://static.infragistics.com/xplatform/css/samples/\r\n*/\r\n","isMain":true,"fileExtension":"scss","fileHeader":"scss"},{"hasRelativeAssetsUrls":false,"path":"src/app/utilities/WorldUtility.ts","content":"export class WorldUtility {\r\n\r\n    // calculate geo-paths between two locations using great circle formula\r\n    public static calcPaths(origin: any, dest: any): any[] {\r\n        const interval = 200;\r\n        const paths: any[] = [[]];\r\n        let pathID = 0;\r\n        const distance = this.calcDistance(origin, dest);\r\n        if (distance <= interval) {\r\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        } else {\r\n            let current = origin;\r\n            let previous = origin;\r\n\r\n            for (let dist = interval; dist <= distance; dist += interval) {\r\n                previous = current;\r\n                paths[pathID].push({ x: current.lon, y: current.lat });\r\n\r\n                const bearing = this.calcBearing(current, dest);\r\n                current = this.calcDestination(current, bearing, interval);\r\n                // ensure geo-path wrap around the world through the new date-line\r\n                if (previous.lon > 150 && current.lon < -150) {\r\n                    paths[pathID].push({ x: 180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++;\r\n                    current = { lon: -180, lat: current.lat };\r\n                } else if (previous.lon < -150 && current.lon > 150) {\r\n                    paths[pathID].push({ x: -180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++;\r\n                    current = { lon: 180, lat: current.lat };\r\n                }\r\n            }\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        }\r\n        return paths;\r\n    }\r\n\r\n    // calculate bearing angle between two locations\r\n    public static calcBearing(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        const range = (dest.lon - origin.lon);\r\n        const y = Math.sin(range) * Math.cos(dest.lat);\r\n        const x = Math.cos(origin.lat) * Math.sin(dest.lat) -\r\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\r\n        const angle = Math.atan2(y, x);\r\n        return this.toDegreesNormalized(angle);\r\n    }\r\n\r\n    // calculate destination for origin location and travel distance\r\n    public static calcDestination(origin: any, bearing: number, distance: number): any {\r\n        const radius = 6371.0;\r\n        origin = this.toRadianLocation(origin);\r\n        bearing = this.toRadians(bearing);\r\n        distance = distance / radius; // angular distance in radians\r\n\r\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\r\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\r\n        const x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\r\n        const y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\r\n        let lon = origin.lon + Math.atan2(x, y);\r\n        // normalize lon to coordinate between -180ยบ and +180ยบ\r\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\r\n\r\n        lon = this.toDegrees(lon);\r\n        lat = this.toDegrees(lat);\r\n\r\n        return { lon, lat };\r\n    }\r\n\r\n    // calculate distance between two locations\r\n    public static calcDistance(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        const sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\r\n        const cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\r\n        const lonDelta = (dest.lon - origin.lon);\r\n\r\n        const angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\r\n        const distance = angle * 6371.0;\r\n        return distance; // * 6371.0; // in km\r\n    }\r\n\r\n    public static toRadianLocation(geoPoint: any): any {\r\n        const x = this.toRadians(geoPoint.lon);\r\n        const y = this.toRadians(geoPoint.lat);\r\n        return { lon: x, lat: y };\r\n    }\r\n\r\n    public static toRadians(degrees: number): number {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    public static toDegrees(radians: number): number {\r\n        return (radians * 180.0 / Math.PI);\r\n    }\r\n\r\n    public static toDegreesNormalized(radians: number): number {\r\n        let degrees = this.toDegrees(radians);\r\n        degrees = (degrees + 360) % 360;\r\n        return degrees;\r\n    }\r\n\r\n    // converts latitude coordinate to a string\r\n    public static toStringLat(latitude: number): string {\r\n        const str = Math.abs(latitude).toFixed(1) + \"ยฐ\";\r\n        return latitude > 0 ? str + \"N\" : str + \"S\";\r\n    }\r\n\r\n    // converts longitude coordinate to a string\r\n    public static toStringLon(coordinate: number): string {\r\n        const val = Math.abs(coordinate);\r\n        const str = val < 100 ? val.toFixed(1) : val.toFixed(0);\r\n        return coordinate > 0 ? str + \"ยฐE\" : str + \"ยฐW\";\r\n    }\r\n\r\n    public static toStringAbbr(value: number): string {\r\n        if (value > 1000000000000) {\r\n            return (value / 1000000000000).toFixed(1) + \" T\";\r\n        } else if (value > 1000000000) {\r\n            return (value / 1000000000).toFixed(1) + \" B\";\r\n        } else if (value > 1000000) {\r\n            return (value / 1000000).toFixed(1) + \" M\";\r\n        } else if (value > 1000) {\r\n            return (value / 1000).toFixed(1) + \" K\";\r\n        }\r\n        return value.toFixed(0);\r\n    }\r\n\r\n    public static getLongitude(location: any): number {\r\n        if (location.x) { return location.x; }\r\n        if (location.lon) { return location.lon; }\r\n        if (location.longitude) { return location.longitude; }\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getLatitude(location: any): number {\r\n        if (location.y) { return location.y; }\r\n        if (location.lat) { return location.lat; }\r\n        if (location.latitude) { return location.latitude; }\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getBounds(locations: any[]): any {\r\n        let minLat = 90;\r\n        let maxLat = -90;\r\n        let minLon = 180;\r\n        let maxLon = -180;\r\n\r\n        for (const location of locations) {\r\n            const crrLon = this.getLongitude(location);\r\n            if (!Number.isNaN(crrLon)) {\r\n                minLon = Math.min(minLon, crrLon);\r\n                maxLon = Math.max(maxLon, crrLon);\r\n            }\r\n\r\n            const crrLat = this.getLatitude(location);\r\n            if (!Number.isNaN(crrLat)) {\r\n                minLat = Math.min(minLat, crrLat);\r\n                maxLat = Math.max(maxLat, crrLat);\r\n            }\r\n        }\r\n\r\n        const geoBounds = {\r\n            left: minLon,\r\n            top: minLat,\r\n            width: Math.abs(maxLon - minLon),\r\n// tslint:disable-next-line: object-literal-sort-keys\r\n            height: Math.abs(maxLat - minLat)\r\n        };\r\n        return geoBounds;\r\n    }\r\n}\r\n"},{"hasRelativeAssetsUrls":false,"path":"src/app/app.module.ts","content":"import { NgModule } from \"@angular/core\";\nimport { FormsModule } from \"@angular/forms\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { BrowserAnimationsModule } from \"@angular/platform-browser/animations\";\nimport { AppComponent } from \"./app.component\";\r\nimport { MapBindingDataModelComponent } from \"./maps/geo-map-binding-data-model/map-binding-data-model.component\";\r\nimport { IgxGeographicMapModule } from \"igniteui-angular-maps\";\n\n\n\n@NgModule({\n  bootstrap: [AppComponent],\n  declarations: [\r\n\tAppComponent,\r\n\tMapBindingDataModelComponent\r\n],\n  imports: [\r\n\tBrowserModule,\r\n\tBrowserAnimationsModule,\r\n\tFormsModule,\r\n\tIgxGeographicMapModule\r\n],\n  providers: [],\n  entryComponents: [],\n  schemas: []\n})\nexport class AppModule {}\n","isMain":true,"fileExtension":"ts","fileHeader":"modules"},{"hasRelativeAssetsUrls":false,"path":"src/app/app.component.html","content":"<app-map-binding-data-model></app-map-binding-data-model>"}],"sampleDependencies":"{\"@angular/animations\":\"10.0.14\",\"@angular/common\":\"10.0.14\",\"@angular/compiler\":\"10.0.14\",\"@angular/core\":\"^10.0.14\",\"@angular/forms\":\"10.0.14\",\"@angular/platform-browser\":\"10.0.14\",\"@angular/platform-browser-dynamic\":\"10.0.14\",\"@types/hammerjs\":\"^2.0.35\",\"classlist.js\":\"^1.1.20150312\",\"core-js\":\"^2.6.2\",\"hammerjs\":\"^2.0.8\",\"igniteui-angular\":\"11.1.10\",\"igniteui-angular-charts\":\"11.2.0-beta.0\",\"igniteui-angular-core\":\"11.2.0-beta.0\",\"igniteui-angular-maps\":\"11.2.0-beta.0\",\"intl\":\"^1.2.5\",\"jszip\":\"^3.1.5\",\"rxjs\":\"^6.5.4\",\"tslib\":\"1.13.0\",\"web-animations-js\":\"^2.3.2\",\"zone.js\":\"~0.10.2\"}"}