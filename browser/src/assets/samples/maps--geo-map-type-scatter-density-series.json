{"sampleFiles":[{"hasRelativeAssetsUrls":false,"path":"src/app/maps/geo-map-type-scatter-density-series/map-type-scatter-density-series.component.ts","content":"import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\";\r\nimport { IgxShapeDataSource } from \"igniteui-angular-core\";\r\nimport { IgxGeographicHighDensityScatterSeriesComponent\r\n} from \"igniteui-angular-maps\";\r\nimport { IgxGeographicMapComponent } from \"igniteui-angular-maps\";\r\nimport { WorldUtility } from \"../../utilities/WorldUtility\";\r\n\r\n@Component({\r\n  selector: \"app-map-type-scatter-density-series\",\r\n  styleUrls: [\"./map-type-scatter-density-series.component.scss\"],\r\n  templateUrl: \"./map-type-scatter-density-series.component.html\"\r\n})\r\n\r\nexport class MapTypeScatterDensitySeriesComponent implements AfterViewInit {\r\n\r\n    @ViewChild(\"map\", {static: true})\r\n    public map: IgxGeographicMapComponent;\r\n    @ViewChild(\"template\", {static: true})\r\n    public tooltip: TemplateRef<object>;\r\n\r\n    public geoLocations;\r\n    constructor() {\r\n    }\r\n\r\n    public ngAfterViewInit(): void {\r\n         // fetching geographic locations from public JSON folder\r\n         fetch(\"https://static.infragistics.com/xplatform/data/AusPlaces.json\")\r\n         .then((response) => response.json())\r\n         .then((data) => this.onDataLoaded(data, \"\"));\r\n      }\r\n\r\n    public onDataLoaded(sds: IgxShapeDataSource, e: any) {\r\n        this.geoLocations = sds;\r\n        // creating HD series with loaded data\r\n        const geoSeries = new IgxGeographicHighDensityScatterSeriesComponent();\r\n        geoSeries.dataSource = sds;\r\n        geoSeries.longitudeMemberPath = \"x\";\r\n        geoSeries.latitudeMemberPath = \"y\";\r\n        geoSeries.heatMaximumColor = \"Red\";\r\n        geoSeries.heatMinimumColor = \"Black\";\r\n        geoSeries.heatMinimum = 0;\r\n        geoSeries.heatMaximum = 5;\r\n        geoSeries.pointExtent = 1;\r\n        geoSeries.tooltipTemplate = this.tooltip;\r\n        geoSeries.mouseOverEnabled = true;\r\n\r\n        // adding HD series to the geographic amp\r\n        this.map.series.add(geoSeries);\r\n\r\n        // zooming to bound of all geographic locations\r\n        const geoBounds = WorldUtility.getBounds(this.geoLocations);\r\n        geoBounds.top = 0;\r\n        geoBounds.height = -50;\r\n        this.map.zoomToGeographic(geoBounds);\r\n    }\r\n\r\n}\r\n","isMain":true,"fileExtension":"ts","fileHeader":"ts"},{"hasRelativeAssetsUrls":false,"path":"src/app/maps/geo-map-type-scatter-density-series/map-type-scatter-density-series.component.html","content":"<div class=\"container sample\">\r\n    <igx-geographic-map #map\r\n        width=\"100%\"\r\n        height=\"100%\"\r\n        zoomable=\"true\" >\r\n    </igx-geographic-map>\r\n\r\n    <ng-template let-series=\"series\" let-item=\"item\" #template>\r\n        <div>\r\n            <span>{{item.n}}</span>\r\n        </div>\r\n    </ng-template>\r\n\r\n</div>\r\n","isMain":true,"fileExtension":"html","fileHeader":"html"},{"hasRelativeAssetsUrls":false,"path":"src/app/maps/geo-map-type-scatter-density-series/map-type-scatter-density-series.component.scss","content":"/* styles are loaded the Shared CSS file located at:\r\nhttps://static.infragistics.com/xplatform/css/samples/\r\n*/\r\n","isMain":true,"fileExtension":"scss","fileHeader":"scss"},{"hasRelativeAssetsUrls":false,"path":"src/app/utilities/WorldUtility.ts","content":"export class WorldUtility {\r\n\r\n    // calculate geo-paths between two locations using great circle formula\r\n    public static calcPaths(origin: any, dest: any): any[] {\r\n        const interval = 200;\r\n        const paths: any[] = [[]];\r\n        let pathID = 0;\r\n        const distance = this.calcDistance(origin, dest);\r\n        if (distance <= interval) {\r\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        } else {\r\n            let current = origin;\r\n            let previous = origin;\r\n\r\n            for (let dist = interval; dist <= distance; dist += interval) {\r\n                previous = current;\r\n                paths[pathID].push({ x: current.lon, y: current.lat });\r\n\r\n                const bearing = this.calcBearing(current, dest);\r\n                current = this.calcDestination(current, bearing, interval);\r\n                // ensure geo-path wrap around the world through the new date-line\r\n                if (previous.lon > 150 && current.lon < -150) {\r\n                    paths[pathID].push({ x: 180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++;\r\n                    current = { lon: -180, lat: current.lat };\r\n                } else if (previous.lon < -150 && current.lon > 150) {\r\n                    paths[pathID].push({ x: -180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++;\r\n                    current = { lon: 180, lat: current.lat };\r\n                }\r\n            }\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        }\r\n        return paths;\r\n    }\r\n\r\n    // calculate bearing angle between two locations\r\n    public static calcBearing(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        const range = (dest.lon - origin.lon);\r\n        const y = Math.sin(range) * Math.cos(dest.lat);\r\n        const x = Math.cos(origin.lat) * Math.sin(dest.lat) -\r\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\r\n        const angle = Math.atan2(y, x);\r\n        return this.toDegreesNormalized(angle);\r\n    }\r\n\r\n    // calculate destination for origin location and travel distance\r\n    public static calcDestination(origin: any, bearing: number, distance: number): any {\r\n        const radius = 6371.0;\r\n        origin = this.toRadianLocation(origin);\r\n        bearing = this.toRadians(bearing);\r\n        distance = distance / radius; // angular distance in radians\r\n\r\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\r\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\r\n        const x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\r\n        const y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\r\n        let lon = origin.lon + Math.atan2(x, y);\r\n        // normalize lon to coordinate between -180º and +180º\r\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\r\n\r\n        lon = this.toDegrees(lon);\r\n        lat = this.toDegrees(lat);\r\n\r\n        return { lon, lat };\r\n    }\r\n\r\n    // calculate distance between two locations\r\n    public static calcDistance(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        const sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\r\n        const cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\r\n        const lonDelta = (dest.lon - origin.lon);\r\n\r\n        const angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\r\n        const distance = angle * 6371.0;\r\n        return distance; // * 6371.0; // in km\r\n    }\r\n\r\n    public static toRadianLocation(geoPoint: any): any {\r\n        const x = this.toRadians(geoPoint.lon);\r\n        const y = this.toRadians(geoPoint.lat);\r\n        return { lon: x, lat: y };\r\n    }\r\n\r\n    public static toRadians(degrees: number): number {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    public static toDegrees(radians: number): number {\r\n        return (radians * 180.0 / Math.PI);\r\n    }\r\n\r\n    public static toDegreesNormalized(radians: number): number {\r\n        let degrees = this.toDegrees(radians);\r\n        degrees = (degrees + 360) % 360;\r\n        return degrees;\r\n    }\r\n\r\n    // converts latitude coordinate to a string\r\n    public static toStringLat(latitude: number): string {\r\n        const str = Math.abs(latitude).toFixed(1) + \"°\";\r\n        return latitude > 0 ? str + \"N\" : str + \"S\";\r\n    }\r\n\r\n    // converts longitude coordinate to a string\r\n    public static toStringLon(coordinate: number): string {\r\n        const val = Math.abs(coordinate);\r\n        const str = val < 100 ? val.toFixed(1) : val.toFixed(0);\r\n        return coordinate > 0 ? str + \"°E\" : str + \"°W\";\r\n    }\r\n\r\n    public static toStringAbbr(value: number): string {\r\n        if (value > 1000000000000) {\r\n            return (value / 1000000000000).toFixed(1) + \" T\";\r\n        } else if (value > 1000000000) {\r\n            return (value / 1000000000).toFixed(1) + \" B\";\r\n        } else if (value > 1000000) {\r\n            return (value / 1000000).toFixed(1) + \" M\";\r\n        } else if (value > 1000) {\r\n            return (value / 1000).toFixed(1) + \" K\";\r\n        }\r\n        return value.toFixed(0);\r\n    }\r\n\r\n    public static getLongitude(location: any): number {\r\n        if (location.x) { return location.x; }\r\n        if (location.lon) { return location.lon; }\r\n        if (location.longitude) { return location.longitude; }\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getLatitude(location: any): number {\r\n        if (location.y) { return location.y; }\r\n        if (location.lat) { return location.lat; }\r\n        if (location.latitude) { return location.latitude; }\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getBounds(locations: any[]): any {\r\n        let minLat = 90;\r\n        let maxLat = -90;\r\n        let minLon = 180;\r\n        let maxLon = -180;\r\n\r\n        for (const location of locations) {\r\n            const crrLon = this.getLongitude(location);\r\n            if (!Number.isNaN(crrLon)) {\r\n                minLon = Math.min(minLon, crrLon);\r\n                maxLon = Math.max(maxLon, crrLon);\r\n            }\r\n\r\n            const crrLat = this.getLatitude(location);\r\n            if (!Number.isNaN(crrLat)) {\r\n                minLat = Math.min(minLat, crrLat);\r\n                maxLat = Math.max(maxLat, crrLat);\r\n            }\r\n        }\r\n\r\n        const geoBounds = {\r\n            left: minLon,\r\n            top: minLat,\r\n            width: Math.abs(maxLon - minLon),\r\n// tslint:disable-next-line: object-literal-sort-keys\r\n            height: Math.abs(maxLat - minLat)\r\n        };\r\n        return geoBounds;\r\n    }\r\n}\r\n"},{"hasRelativeAssetsUrls":false,"path":"src/app/app.module.ts","content":"import { NgModule } from \"@angular/core\";\nimport { FormsModule } from \"@angular/forms\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { BrowserAnimationsModule } from \"@angular/platform-browser/animations\";\nimport { AppComponent } from \"./app.component\";\r\nimport { MapTypeScatterDensitySeriesComponent } from \"./maps/geo-map-type-scatter-density-series/map-type-scatter-density-series.component\";\r\nimport { IgxGeographicMapModule } from \"igniteui-angular-maps\";\n\n\n\n@NgModule({\n  bootstrap: [AppComponent],\n  declarations: [\r\n\tAppComponent,\r\n\tMapTypeScatterDensitySeriesComponent\r\n],\n  imports: [\r\n\tBrowserModule,\r\n\tBrowserAnimationsModule,\r\n\tFormsModule,\r\n\tIgxGeographicMapModule\r\n],\n  providers: [],\n  entryComponents: [],\n  schemas: []\n})\nexport class AppModule {}\n","isMain":true,"fileExtension":"ts","fileHeader":"modules"},{"hasRelativeAssetsUrls":false,"path":"src/app/app.component.html","content":"<app-map-type-scatter-density-series></app-map-type-scatter-density-series>"}],"sampleDependencies":"{\"@angular/animations\":\"10.0.14\",\"@angular/common\":\"10.0.14\",\"@angular/compiler\":\"10.0.14\",\"@angular/core\":\"^10.0.14\",\"@angular/forms\":\"10.0.14\",\"@angular/platform-browser\":\"10.0.14\",\"@angular/platform-browser-dynamic\":\"10.0.14\",\"@types/hammerjs\":\"^2.0.35\",\"classlist.js\":\"^1.1.20150312\",\"core-js\":\"^2.6.2\",\"hammerjs\":\"^2.0.8\",\"igniteui-angular\":\"11.1.10\",\"igniteui-angular-charts\":\"11.2.0-beta.0\",\"igniteui-angular-core\":\"11.2.0-beta.0\",\"igniteui-angular-maps\":\"11.2.0-beta.0\",\"intl\":\"^1.2.5\",\"jszip\":\"^3.1.5\",\"rxjs\":\"^6.5.4\",\"tslib\":\"1.13.0\",\"web-animations-js\":\"^2.3.2\",\"zone.js\":\"~0.10.2\"}"}